/** Using a Queue to generate new numbers from previous numbers */

"use strict" 
function findBin(n) {
    let result = [];
    let myQueue = new Queue();
    var s1, s2;
    myQueue.enqueue("1");
    for (var i = 0; i < n; i++) {
        result.push(myQueue.dequeue());
        s1 = result[i] + "0";
        s2 = result[i] + "1";
        
        myQueue.enqueue(s1);
        myQueue.enequeu(s2);
    

    }

}
/**
The crux of the solution is to generate consecutive binary numbers from previous binary numbers by appending 0 and 1 to each of them. For example,

10 and 11 can be generated when 0 and 1 are appended to 1.
100 and 101 are generated when 0 and 1 are appended to 10.
As soon as a binary number is generated, it is enqueued to a queue so that new binary numbers can be generated by appending 0 and 1 when that number will be enqueued. As the queue follows the First-In, First-Out property, the enqueued binary numbers are dequeued in an order such that the overall resultant array is mathematically correct.

Letâ€™s get to the code now. On line 7, 1 is enqueued as a starting point. Now, to generate the binary number sequence, a number is dequeued from the queue and stored in the result array. On lines 11-12, 0 and 1 are appended to it to produce the next numbers, which are then also enqueued to the queue on lines 14-15. The queue takes integer values, so before enqueueing, the solution makes sure to convert the string to an integer.

Time Complexity
The time complexity of this solution is in O(n)
O(n)
 as constant-time operations are executed for n times.
 */